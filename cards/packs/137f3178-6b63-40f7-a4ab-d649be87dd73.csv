front,back,front_color,back_color,attemps,correct
Explain how a bubble sort can sort a list.,"<ul><li>Compare the first two items in the list.</li><li>If they are in the wrong order then swap them.</li><li>Move to the next pair of items.</li><li>Repeat until the end of the list is reached, this will be the first pass.</li><li>Make a second pass through the list for one less iteration, as the last item is now in order.</li><li>Once a pass is made with no swaps, the list is sorted.</li></ul>",,,1,1
Explain how a breadth-first traversal is used to traverse a graph.,"<ul><li>From start node, add all neighbours to a visited queue, and mark start node as discovered.</li><li>Dequeue neighbour queue, mark that node as discovered, and add its unvisited/undiscovered neighbours to the queue.</li><li>Effectively, traverse all of the children of one node before going down to their children.</li><li>Continue until the queue becomes empty, at which point graph is fully traversed.</li></ul>",,,1,1
What is breadth-first search (BFS)?<br>What is it typically used for?,"<ul><li>BFS explores all neighbours of a node before moving to the next level (layer-by-layer).</li><li>It uses a queue (FIFO) data structure.</li><li>Applications: finding the shortest path in an unweighted graph, peer-to-peer networks, GPS navigation (unweighted maps).</li></ul>",,,0,0
What is depth-first search (DFS)?<br>What is it typically used for?,"<ul><li>DFS explores as far as possible down one branch before backtracking.</li><li>It uses a stack (explicit or via recursion).</li><li>Applications: maze solving, topological sorting, cycle detection, scheduling problems.</li></ul>",,,0,0
Compare breadth-first search (BFS) and depth-first search (DFS).<br>Which is more suitable for shortest path finding?,"<ul><li>BFS guarantees shortest path in an unweighted graph, DFS does not.</li><li>BFS uses a queue → requires more memory, but ensures optimal path.</li><li>DFS uses a stack/recursion → less memory in sparse graphs, but may get ""lost"" in deep branches.</li><li>Exam tip: AQA often asks why BFS is better for shortest path questions → because it visits nodes in increasing distance order.</li></ul>",,,0,0
What are the three tree traversal methods?<br>Give one use for each.,"<ul><li>Pre-order: Root → Left → Right. Used for copying/cloning trees.</li><li>In-order: Left → Root → Right. Used for binary search trees (BSTs) → outputs nodes in ascending order.</li><li>Post-order: Left → Right → Root. Used for deleting/freeing trees, and converting infix to postfix (RPN).</li></ul>",,,0,0
"In a binary search tree, which traversal would give values in ascending order? Why?","In-order traversal gives ascending order.Because it visits left subtree (smaller values), then root, then right subtree (larger values), maintaining BST ordering.",,,0,0
What is Reverse Polish Notation (RPN)?<br>Why is it used?,"<ul><li>RPN is a mathematical notation where operators come after operands.</li><li>Removes need for brackets → expression evaluation is unambiguous.</li><li>Efficient for computers: evaluation via stack-based interpreters (PostScript, Java bytecode).</li></ul>",,,0,0
Convert the infix expression '(3 + 4) * 5' into RPN.<br>Convert '7 3 + 2 *' back into infix.,<ul><li>Infix (3 + 4) * 5 → RPN: 3 4 + 5 *.</li><li>RPN 7 3 + 2 * → Infix: (7 + 3) * 2.</li></ul>,,,0,0
What is the time complexity of linear search?<br>Why is it inefficient compared to binary search?,"<ul><li>O(n) time complexity.</li><li>Must check each element in worst case.</li><li>Inefficient compared to binary search (O(log n)), especially for large, sorted datasets.</li></ul>",,,0,0
What is binary search?<br>What condition must hold for binary search to work?,<ul><li>Binary search repeatedly halves the search interval until the target is found.</li><li>Requires the list to be sorted.</li><li>Time complexity: O(log n).</li></ul>,,,0,0
Compare binary search and binary tree search.<br>When might binary tree search be less efficient than binary search?,"<ul><li>Both aim for O(log n) average complexity.</li><li>Binary search works on arrays/lists; binary tree search works on binary search trees (BSTs).</li><li>If a BST is unbalanced (like a linked list), time complexity degrades to O(n).</li></ul>",,,0,0
What is the time complexity of bubble sort?<br>Why is bubble sort considered inefficient?,<ul><li>Worst and average case: O(n²).</li><li>Compares and swaps adjacent elements repeatedly until sorted.</li><li>Inefficient: large number of comparisons/swaps compared to divide-and-conquer methods.</li></ul>,,,0,0
Describe merge sort.<br>What is its time complexity?,"<ul><li>Merge sort is a divide and conquer algorithm: splits list into halves, recursively sorts, then merges.</li><li>Time complexity: O(n log n) in best, worst, and average cases.</li><li>Efficient and stable, but requires extra memory for merging.</li></ul>",,,0,0
Compare bubble sort and merge sort.<br>Which is more suitable for large datasets? Why?,"<ul><li>Bubble sort: O(n²) → impractical for large n.</li><li>Merge sort: O(n log n) consistently.</li><li>Merge sort is far more efficient for large datasets, but bubble sort may be used in teaching or very small datasets due to simplicity.</li></ul>",,,0,0
What is Dijkstra’s shortest path algorithm used for?<br>What are some real-world applications?,"<ul><li>Dijkstra finds the shortest path from a starting node to all other nodes in a weighted graph (non-negative weights).</li><li>Applications: GPS navigation, network routing (e.g. OSPF protocol), task scheduling.</li><li>Exam tip: You don’t need to memorise the full steps, but must be able to trace an example.</li></ul>",,,0,0
Compare Dijkstra’s algorithm and BFS.<br>When would you use one over the other?,<ul><li>BFS finds shortest path in an unweighted graph.</li><li>Dijkstra handles weighted graphs (positive weights).</li><li>If all edges have equal weight → BFS is more efficient. If weights differ → must use Dijkstra.</li></ul>,,,0,0
"In terms of algorithmic complexity, which is more efficient:<br><ol><li>Binary Search</li><li>Linear Search</li><li>Merge Sort</li><li>Bubble Sort</li></ol>",<ul><li>Binary search: O(log n) → efficient for searching sorted data.</li><li>Linear search: O(n) → inefficient for large datasets.</li><li>Merge sort: O(n log n) → efficient sorting.</li><li>Bubble sort: O(n²) → inefficient sorting.</li><li>Ranking (best to worst for large n): Binary search → Merge sort → Linear search → Bubble sort.</li></ul>,,,0,0
"What is meant by ""Divide and Conquer""?<br>Which algorithms in this section use it?","<ul><li>Divide and Conquer = breaking a problem into smaller subproblems, solving them, then combining results.</li><li>Merge sort is the classic example.</li><li>Binary search also uses Divide and Conquer (halving the list each step).</li></ul>",,,0,0
